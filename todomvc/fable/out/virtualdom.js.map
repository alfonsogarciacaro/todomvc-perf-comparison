{"version":3,"sources":["../virtualdom.fsx"],"names":[],"mappings":"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","file":"virtualdom.js","sourcesContent":["(**\n - title: The Elm architecture using Fable\n - tagline: Fable implementation of the Elm architecture\n - app-style: width:800px; margin:20px auto 50px auto;\n - require-paths: `'virtual-dom':'/samples/virtualdom/lib/virtual-dom'`\n - intro: This demo is an implementation of the [Elm architecture](http://guide.elm-lang.org/architecture/)\n   using the same [virtual-dom](https://github.com/Matt-Esch/virtual-dom) as Elm originally used.\n   Contributed by [Tomas Jansson](https://twitter.com/TomasJansson).\n*)\n(*** hide ***)\n#r \"node_modules/fable-core/Fable.Core.dll\"\n#load \"node_modules/fable-import-virtualdom/Fable.Helpers.Virtualdom.fs\"\n//#load \"../../../import/virtualdom/Fable.Helpers.Virtualdom.fs\"\n(**\n##Architecture overview\n\nThe beauty of the architecture Elm is using for their application is its\nsimplicity. You can read and grasp the whole architecture in a matter of minutes\nhere: http://guide.elm-lang.org/architecture/. I won't explain the architecture\nfurther, instead I will go straight to the examples.\n\n###First example - a simple counter\n\nThe counter below is something you can increment and decrement by clicking on\nthe text. It will also modify the size of the elements with the counter as well\nas the background color of the actual counter.\n\n<div id=\"counter\">\n</div>\n\n*)\nopen Fable.Core\nopen Fable.Import\nopen Fable.Import.Browser\n\nopen Fable.Helpers.Virtualdom\nopen Fable.Helpers.Virtualdom.App\nopen Fable.Helpers.Virtualdom.Html\n\n// model\n//type Counter = int\n//let initCounter = 0\n//\n//(**\n//The model for the first example is a simple integer that will act as hour counter.\n//We also provide a default value for our counter.\n//*)\n//\n//// Update\n//type CounterAction =\n//    | Decrement of int\n//    | Increment of int\n//\n//let counterUpdate model action =\n//    match action with\n//    | Decrement x -> model - x\n//    | Increment x -> model + x\n//    |> (fun m -> m,[])\n//\n//(**\n//The counter can be incremented or decremented in step of `x`. If you look closely\n//the update function return the new model and a list of something. The list of\n//something is list of calls js-calls of type `unit->unit` that should be executed\n//after this version of the model has been rendered. We will see in a later example\n//why this is useful.\n//*)\n//\n//// View\n//let counterView handler model =\n//    let bgColor =\n//        match model with\n//        | x when x > 100 -> \"red\"\n//        | x when x < 0 -> \"blue\"\n//        | _ -> \"green\"\n//    div []\n//        [\n//            div [   Style [\"border\",\"1px solid blue\"]\n//                    onMouseClick (fun x -> handler (Increment 1))\n//                    onDblClick (fun x -> handler ((Increment 100)))] [text (string \"Increment\")]\n//            div [ Style [\"background-color\", bgColor; \"color\", \"white\"]] [text (string model)]\n//            div [   Style [\"border\", \"1px solid green\"; \"height\", ((string (70 + model)) + \"px\")]\n//                    onMouseClick (fun x -> handler (Decrement 1))\n//                    onDblClick (fun x -> handler (Decrement 50))]\n//                [text (string \"Decrement\")]\n//        ]\n//\n//(**\n//The `counterView` defines how a model should be rendered. It also takes a `handler`\n//that should have a function of the type `'TAction -> unit`, this makes it possible\n//to react user actions like we do here on simple mouse actions. The dsl that is used\n//here is quite simple and have helper functions for a majority of the standard\n//HTML elements. It is trivial to add custom tags if you are missing some tag\n//that you would like to use.\n//*)\n//\n//// Start the application\n//let counterApp =\n//    createApp {Model = initCounter; View = counterView; Update = counterUpdate}\n//    |> withStartNode \"#counter\"\n//\n//counterApp |> start renderer\n//\n(**\nThe dsl has been separated from the actual rendering of the dsl, to allow for\nfuture server side rendering as well. So to get this application started you first\nneed to create the application with the `createApp` function. The we pass that\nresult to a helper function to specify where in the document it should be rendered,\ndefault is directly in the body. When we have defined an application we can call\nthe `start` function and pass in a `renderer`. We are using the standard `renderer`\nfor `virtual-dom.js`, but this separation makes it a little bit easier to change\nto another framework in the future.\n\nThat's it, the first application is done and we are ready for example 2.\n\n### Second example - todomvc\n\nTo have something to compare to other js-framework, Elm and whatnot a todomvc app\nis in its place. If you don't know what todomvc is check it out here:\nhttp://todomvc.com/. The app below should have all the features expected from a\ntodomvc app.\n\n<div id=\"todo\">\n</div>\n\nWe will follow the exact same steps as with the counter example. First implement\nthe model, then the update function that to handle actions and lastly the view.\nThis example is a little bit longer and have some more features. I'll also show\nhow easy it is to store data from the model in the local storage, and that could\neasily be swapped to server side storage without effecting any of the application\ncode. Let's start.\n*)\n\n// Todo model\ntype Filter =\n    | All\n    | Completed\n    | Active\n\ntype Item =\n    {\n        Name: string\n        Done: bool\n        Id: int\n        IsEditing: bool\n    }\n\ntype TodoModel =\n    {\n        Items: Item list\n        Input: string\n        Filter: Filter\n    }\n\n(**\nThe model is really simple. It consists of a list of items, which you can edit\nand they can be marked as done. You also have a input field and something to\nfilter the models with. I use a discriminated union to filter the items, which\nis a nice feature you don't have in standard js.\n*)\n\n// Todo update\ntype TodoAction =\n    | AddItem of Item\n    | ChangeInput of string\n    | MarkAsDone of Item\n    | ToggleItem of Item\n    | Destroy of Item\n    | CheckAll\n    | UnCheckAll\n    | SetActiveFilter of Filter\n    | ClearCompleted\n    | EditItem of Item\n    | SaveItem of Item*string\n\n(**\nFirst we define the actual actions before moving on to the actual update function.\n*)\n\nlet todoUpdate model msg =\n    let checkAllWith v =\n        { model with Items = model.Items |> List.map (fun i -> { i with Done = v })}\n\n    let updateItem i model =\n        let items' =\n            model.Items |> List.map (fun i' -> if i'.Id <> i.Id then i' else i)\n        {model with Items = items'}\n\n    let model' =\n        match msg with\n        | AddItem item ->\n            let maxId =\n                if model.Items |> List.isEmpty then 1\n                else\n                    model.Items\n                    |> List.map (fun x -> x.Id)\n                    |> List.max\n            let item' = {item with Id = maxId + 1}\n            {model with Items = item'::model.Items; Input = \"\"}\n        | ChangeInput v -> {model with Input = v}\n        | MarkAsDone i ->\n            let items' =\n                model.Items |> List.map (fun i' -> if i' <> i then i' else {i with Done = true})\n            {model with Items = items'}\n        | CheckAll -> checkAllWith true\n        | UnCheckAll -> checkAllWith false\n        | Destroy i -> {model with Items = model.Items |> List.filter (fun i' -> i'.Id <> i.Id)}\n        | ToggleItem i -> updateItem {i with Done = not i.Done} model\n        | SetActiveFilter f -> { model with Filter = f }\n        | ClearCompleted -> { model with Items = model.Items |> List.filter (fun i -> not i.Done)}\n        | EditItem i -> updateItem { i with IsEditing = true} model\n        | SaveItem (i,str) -> updateItem { i with Name = str; IsEditing = false} model\n\n    let jsCalls =\n        match msg with\n        | EditItem i -> [fun () -> document.getElementById(\"item-\" + (i.Id.ToString())).focus()]\n        | _ -> []\n    model',jsCalls\n\n(**\nIt might seem like a lot of code, but we need to handle all actions and respond\nto them accordingly. I won't go into the detail in all the scenarios, but you\nshould pay attention to the step where `jsCalls` is defined. Since we are re-rendering\nthe application on changes in the model, or render what has changed as least, we need\na way to give an input focus if we start edit it. That is when the list of js\nfunction calls come in handy. So the update function returns the new model a\nlong side a list of js function calls if we need to do something after rendering,\nand that is something we need to do when we start edit an item, we want to give\nthat item focus.\n\nWith this done all we need is to define the view.\n*)\n\n// Todo view\nlet filterToTextAndUrl = function\n    | All -> \"All\", \"\"\n    | Completed -> \"Completed\", \"completed\"\n    | Active -> \"Active\", \"active\"\n\nlet filter handler activeFilter f =\n    let linkClass = if f = activeFilter then \"selected\" else \"\"\n    let fText,url = f |> filterToTextAndUrl\n    li\n        [ onMouseClick (fun _ -> SetActiveFilter f |> handler)]\n        [ a\n            [ attribute \"href\" (\"#/\" + url); attribute \"class\" linkClass ]\n            [ text fText] ]\n\nlet filters model handler =\n    ul\n        [ attribute \"class\" \"filters\" ]\n        ([ All; Active; Completed ] |> List.map (filter handler model.Filter))\n\nlet todoFooter model handler =\n    let clearVisibility =\n        if model.Items |> List.exists (fun i -> i.Done)\n        then \"\"\n        else \"none\"\n    let activeCount = model.Items |> List.filter (fun i -> not i.Done) |> List.length |> string\n    footer\n        [   attribute \"class\" \"footer\"; Style [\"display\",\"block\"]]\n        [   span\n                [ attribute \"class\" \"todo-count\" ]\n                [   strong [] [text activeCount]\n                    text \" items left\" ]\n            (filters model handler)\n            button\n                [   attribute \"class\" \"clear-completed\"\n                    Style [ \"display\", clearVisibility ]\n                    onMouseClick (fun _ -> handler ClearCompleted)]\n                [ text \"Clear completed\" ] ]\n\n\nlet todoHeader model handler =\n    header\n        [attribute \"class\" \"header\"]\n        [   h1 [] [text \"todos\"]\n            input [ attribute \"class\" \"new-todo\"\n                    attribute \"id\" \"new-todo\"\n                    property \"placeholder\" \"What needs to be done?\"\n                    property \"value\" model\n                    onKeydown (fun x ->\n                        if x.keyCode = 13\n                        then handler (AddItem {Name = model; Id = 0; Done = false; IsEditing = false})\n                        )\n                    onKeyup (fun x -> handler (ChangeInput (x?target?value :?> string))) ]]\n\nlet listItem handler item =\n    let itemChecked = if item.Done then \"true\" else \"\"\n    let editClass = if item.IsEditing then \"editing\" else \"\"\n    li [ attribute \"class\" ((if item.Done then \"completed \" else \" \") + editClass)]\n       [ div [  attribute \"class\" \"view\"\n                onDblClick (fun x -> EditItem item |> handler) ]\n             [ input [  property \"className\" \"toggle\"\n                        property \"type\" \"checkbox\"\n                        property \"checked\" itemChecked\n                        onMouseClick (fun e -> handler (ToggleItem item)) ]\n               label [] [ text item.Name ]\n               button [ attribute \"class\" \"destroy\"\n                        onMouseClick (fun e -> handler (Destroy item)) ] [] ]\n         input [ attribute \"class\" \"edit\"\n                 attribute \"value\" item.Name\n                 property \"id\" (\"item-\"+item.Id.ToString())\n                 onBlur (fun e -> SaveItem (item, (e?target?value :?> string)) |> handler) ] ]\n\nlet itemList handler items activeFilter =\n    let filterItems i =\n        match activeFilter with\n        | All -> true\n        | Completed -> i.Done\n        | Active -> not i.Done\n\n    ul [attribute \"class\" \"todo-list\" ]\n       (items |> List.filter filterItems |> List.map (listItem handler))\n\nlet todoMain model handler =\n    let items = model.Items\n    let allChecked = items |> List.exists (fun i -> not i.Done)\n    section [  attribute \"class\" \"main\"\n               Style [ \"style\", \"block\" ] ]\n            [   input [ property \"id\" \"toggle-all\"\n                        attribute \"class\" \"toggle-all\"\n                        property \"type\" \"checkbox\"\n                        property \"checked\" (if not allChecked then \"true\" else \"\")\n                        onMouseClick (fun e ->\n                                    if allChecked\n                                    then handler CheckAll\n                                    else handler UnCheckAll) ]\n                label [ attribute \"for\" \"toggle-all\" ]\n                      [ text \"Mark all as complete\" ]\n                (itemList handler items model.Filter) ]\n\nlet todoView handler model =\n    section\n        [attribute \"class\" \"todoapp\"]\n        ((todoHeader model.Input handler)::(if model.Items |> List.isEmpty\n                then []\n                else [  (todoMain model handler)\n                        (todoFooter model handler) ] ))\n\n(**\nThis view is more complex than the first example, but it also show how easy it is\nto split a view up into pieces and then combine them together to form a whole. This\nmakes it quite easy to re-use parts in different views.\n\nOne thing to notice is that only a few properties are mapped at the moment, but if\nyou know the property name you can use the syntax `e?target?value`, which will\nlook app the `value` property on the `target` property on the `e` event as in the\nexample above.\n\nBefore this is done, there are one hidden gem that is worth knowing, and it will\nbe showed with two examples. We will add local storage support of the items and a\nlogger of all the actions and model changes. First we need a helper for the storage.\n*)\n\n// Storage\nmodule Storage =\n    let private STORAGE_KEY = \"vdom-storage\"\n    open Microsoft.FSharp.Core\n    let fetch<'T> (): 'T [] =\n        Browser.localStorage.getItem(STORAGE_KEY)\n        |> function null -> \"[]\" | x -> unbox x\n        |> JS.JSON.parse |> unbox\n\n    let save<'T> (todos: 'T []) =\n        Browser.localStorage.setItem(STORAGE_KEY, JS.JSON.stringify todos)\n\n(**\nThe module above is a simple helper to store a list of items in local storage\nof the browser, now let's add it and support for logging.\n*)\n\nopen Storage\n//let initList = fetch<Item>() |> List.ofArray\nlet initModel = {Filter = All; Items = []; Input = \"\"}\n\nlet todoApp =\n    createApp {Model = initModel; View = todoView; Update = todoUpdate}\n//    |> (withSubscriber \"storagesub\" (function\n//            | ModelChanged (newModel,old) -> save (newModel.Items |> Array.ofList)\n//            | _ -> ()))\n//    |> (withSubscriber \"modellogger\" (printfn \"%A\"))\n    |> withStartNode \"#todo\"\n\ntodoApp |> start renderer\n\n(**\nFirst we initiate the model by checking the local storage if there are any items\nthere. The to add support for local storage we add a subscriber. A subscriber is\na function that handles `AppEvents`, they can be `ModelChanged` or `ActionReceived`.\nFor the storage we are only interested in model changes, so that is what we act on\nand store the list of items in the local storage when the model was changed. For\nthe logger we just logs everything.\n\nWe also start the application on the `#todo` element in the document.\n*)\n"]}